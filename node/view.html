<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <title>sonicsphere</title>
</head>
<body>
  
  <script src="https://code.jquery.com/jquery-1.10.2.min.js"></script>
  <script src="https://cdn.socket.io/socket.io-1.3.5.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r71/three.min.js"></script>
  <script>

  THREE.IcosahedronGeometry = function ( radius, detail ) {

  var t = ( 1 + Math.sqrt( 5 ) ) / 2;

  var vertices = [
    - 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
     0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
     t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
  ];

  var indices = [
     0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
     1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
     3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
     4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
  ];

  THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

  this.type = 'IcosahedronGeometry';

  this.parameters = {
    radius: radius,
    detail: detail
  };
};

THREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;

  $(function() {

    var socket = io();
    socket.connect('http://127.0.0.1:3000');
    console.log(socket);

    // Whenever the server emits 'new message', update the chat body

    /*socket.on('q', function (data) {
      $("#accel").html(data.a[0] + " " + data.a[1] + " " + data.a[2]);
    });
*/


    var geometry = new THREE.IcosahedronGeometry( 100 );
    var material = new THREE.MeshLambertMaterial({ color: 0xff0000, shading: THREE.FlatShading, vertexColors: THREE.VertexColors  } );
    mesh = new THREE.Mesh( geometry, material );
    wireframe = new THREE.WireframeHelper( mesh, 0x00ff00 );

    socket.on('q', function(data) {
      var rotateQuaternion = new THREE.Quaternion(data.q[0], data.q[1], data.q[2], data.q[3]);
      mesh.setRotationFromQuaternion(rotateQuaternion);
    });

      var camera, scene, renderer;
      var mesh;

      init();
      animate();

      function init() {

        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );

        //

        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
        camera.position.z = 400;

        scene = new THREE.Scene();

        pickingScene = new THREE.Scene();
        pickingTexture = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight );
        pickingTexture.minFilter = THREE.LinearFilter;
        pickingTexture.generateMipmaps = false;

        scene.add( new THREE.AmbientLight( 0x555555 ) );

        var light = new THREE.SpotLight( 0xffffff, 1.5 );
        light.position.set( 0, 500, 2000 );
        scene.add( light );

        
        scene.add( mesh );
        scene.add( wireframe );

        //

        window.addEventListener( 'resize', onWindowResize, false );

      }

      function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

      }

      function animate() {

        requestAnimationFrame( animate );

        renderer.render( scene, camera );

      }

  });
  </script>
</body>
</html>